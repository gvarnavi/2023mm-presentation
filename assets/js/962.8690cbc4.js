"use strict";(self.webpackChunk_2023_mm_presentation=self.webpackChunk_2023_mm_presentation||[]).push([[962],{5162:(e,t,n)=>{n.d(t,{Z:()=>a});var r=n(7294),i=n(6010);const o={tabItem:"tabItem_Ymn6"};function a(e){let{children:t,hidden:n,className:a}=e;return r.createElement("div",{role:"tabpanel",className:(0,i.Z)(o.tabItem,a),hidden:n},t)}},4866:(e,t,n)=>{n.d(t,{Z:()=>x});var r=n(7462),i=n(7294),o=n(6010),a=n(2466),l=n(6550),s=n(1980),c=n(7392),u=n(12);function _(e){return function(e){return i.Children.map(e,(e=>{if(!e||(0,i.isValidElement)(e)&&function(e){const{props:t}=e;return!!t&&"object"==typeof t&&"value"in t}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)}))?.filter(Boolean)??[]}(e).map((e=>{let{props:{value:t,label:n,attributes:r,default:i}}=e;return{value:t,label:n,attributes:r,default:i}}))}function f(e){const{values:t,children:n}=e;return(0,i.useMemo)((()=>{const e=t??_(n);return function(e){const t=(0,c.l)(e,((e,t)=>e.value===t.value));if(t.length>0)throw new Error(`Docusaurus error: Duplicate values "${t.map((e=>e.value)).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e}),[t,n])}function p(e){let{value:t,tabValues:n}=e;return n.some((e=>e.value===t))}function d(e){let{queryString:t=!1,groupId:n}=e;const r=(0,l.k6)(),o=function(e){let{queryString:t=!1,groupId:n}=e;if("string"==typeof t)return t;if(!1===t)return null;if(!0===t&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:t,groupId:n});return[(0,s._X)(o),(0,i.useCallback)((e=>{if(!o)return;const t=new URLSearchParams(r.location.search);t.set(o,e),r.replace({...r.location,search:t.toString()})}),[o,r])]}function v(e){const{defaultValue:t,queryString:n=!1,groupId:r}=e,o=f(e),[a,l]=(0,i.useState)((()=>function(e){let{defaultValue:t,tabValues:n}=e;if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(t){if(!p({value:t,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${t}" but none of its children has the corresponding value. Available values are: ${n.map((e=>e.value)).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return t}const r=n.find((e=>e.default))??n[0];if(!r)throw new Error("Unexpected error: 0 tabValues");return r.value}({defaultValue:t,tabValues:o}))),[s,c]=d({queryString:n,groupId:r}),[_,v]=function(e){let{groupId:t}=e;const n=function(e){return e?`docusaurus.tab.${e}`:null}(t),[r,o]=(0,u.Nk)(n);return[r,(0,i.useCallback)((e=>{n&&o.set(e)}),[n,o])]}({groupId:r}),m=(()=>{const e=s??_;return p({value:e,tabValues:o})?e:null})();(0,i.useLayoutEffect)((()=>{m&&l(m)}),[m]);return{selectedValue:a,selectValue:(0,i.useCallback)((e=>{if(!p({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),c(e),v(e)}),[c,v,o]),tabValues:o}}var m=n(2389);const b={tabList:"tabList__CuJ",tabItem:"tabItem_LNqP"};function h(e){let{className:t,block:n,selectedValue:l,selectValue:s,tabValues:c}=e;const u=[],{blockElementScrollPositionUntilNextRender:_}=(0,a.o5)(),f=e=>{const t=e.currentTarget,n=u.indexOf(t),r=c[n].value;r!==l&&(_(t),s(r))},p=e=>{let t=null;switch(e.key){case"Enter":f(e);break;case"ArrowRight":{const n=u.indexOf(e.currentTarget)+1;t=u[n]??u[0];break}case"ArrowLeft":{const n=u.indexOf(e.currentTarget)-1;t=u[n]??u[u.length-1];break}}t?.focus()};return i.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,o.Z)("tabs",{"tabs--block":n},t)},c.map((e=>{let{value:t,label:n,attributes:a}=e;return i.createElement("li",(0,r.Z)({role:"tab",tabIndex:l===t?0:-1,"aria-selected":l===t,key:t,ref:e=>u.push(e),onKeyDown:p,onClick:f},a,{className:(0,o.Z)("tabs__item",b.tabItem,a?.className,{"tabs__item--active":l===t})}),n??t)})))}function w(e){let{lazy:t,children:n,selectedValue:r}=e;const o=(Array.isArray(n)?n:[n]).filter(Boolean);if(t){const e=o.find((e=>e.props.value===r));return e?(0,i.cloneElement)(e,{className:"margin-top--md"}):null}return i.createElement("div",{className:"margin-top--md"},o.map(((e,t)=>(0,i.cloneElement)(e,{key:t,hidden:e.props.value!==r}))))}function g(e){const t=v(e);return i.createElement("div",{className:(0,o.Z)("tabs-container",b.tabList)},i.createElement(h,(0,r.Z)({},e,t)),i.createElement(w,(0,r.Z)({},e,t)))}function x(e){const t=(0,m.Z)();return i.createElement(g,(0,r.Z)({key:String(t)},e))}},7688:(e,t,n)=>{function r(e){return e`# Ptychography Helper Functions`}function i(e){return e.html`<hr class="hideable-md">`}function o(e){return e("https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.16/dist/numjs.min.js")}function a(e){return e("https://bundle.run/ndarray-ops@1.2.2")}function l(e){return e("https://bundle.run/ndarray-complex@1.0.3")}function s(e,t){return function(n,r){let i=e.zeros(n.shape);return t.atan2(i.selection,n.selection,r.selection),i}}function c(e,t){return function(n,r){let i=e.zeros(n.shape);return t.lts(i.selection,n.selection,r),t.bandseq(i.selection,1),i}}function u(e,t,n){return class r{constructor(t){this.shape=t;let n=t.slice();n.push(2),this.data=e.zeros(n),this._nulls=new Array(t.length).fill(null)}re(){return this.data.pick(...this._nulls,0)}im(){return this.data.pick(...this._nulls,1)}abs(){return e.sqrt(this.abs_sqr())}abs_sqr(){return e.add(this.re().multiply(this.re()),this.im().multiply(this.im()))}angle(){return t(this.im(),this.re())}clone(){let e=new r(this.shape);return e.data=this.data.clone(),e}conjugate(){let t=this.re().clone(),i=this.im().clone();n.conjeq(t.selection,i.selection);let o=new r(this.shape);return o.data=e.stack([t,i],-1),o}multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}real_multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t,l=e.zeros(t.shape);n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}scalar_multiply(t,i){let o=this.re().clone(),a=this.im().clone();n.mulseq(o.selection,a.selection,t,i);let l=new r(this.shape);return l.data=e.stack([o,a],-1),l}add(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.addeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}subtract(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.subeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}}}function _(e){return function(t,n){let r=e.zeros(t),i=1/(t*n),o=1+((t-1)/2|0);for(var a=0;a<o;a++)r.set(a,a*i);for(a=o;a<t;a++)r.set(a,(a-t)*i);return r}}function f(e){return function(t,n){let r=[t.size,n.size],i=[];i[0]=e.zeros(r),i[1]=e.zeros(r);for(let e=0;e<r[1];e++)for(let o=0;o<r[0];o++)i[0].set(o,e,t.get(o)),i[1].set(o,e,n.get(e));return i}}function p(e){return function(t){let[n,r]=t.shape,i=n/2|0,o=r/2|0,a=e.zeros([n,r]);return a.slice([null,i],[null,o]).assign(t.slice(-i,-o),!1),a.slice([null,i],o).assign(t.slice(-i,[null,o]),!1),a.slice(-i,-o).assign(t.slice([null,i],[null,o]),!1),a.slice(-i,[null,o]).assign(t.slice([null,i],-o),!1),a}}function d(e,t,n,r){return function(i,o){let[a,l]=i.shape,[s,c]=o,u=new e([a,l]);u.data=t.fft(i.data);let _=n(a,1),f=n(l,1),[p,d]=r(_,f),v=-2*Math.PI,m=t.add(p.multiply(s),d.multiply(c)).multiply(v),b=new e([a,l]),h=t.cos(m),w=t.sin(m);b.data=t.stack([h,w],-1);let g=u.multiply(b);return g.data=t.ifft(g.data),g}}function v(e){return function(t,[n,r]){let i=new e([n,r]),o=n/2|0,a=r/2|0;return i.data.slice([null,o],[null,a],null).assign(t.slice([null,o],[null,a],null),!1),i.data.slice(-o,[null,a],null).assign(t.slice(-o,[null,a],null),!1),i.data.slice([null,o],-a,null).assign(t.slice([null,o],-a,null),!1),i.data.slice(-o,-a,null).assign(t.slice(-o,-a,null),!1),i}}function m(e,t,n){return function(r,i){let[o,a]=r.shape;console.log(o);let l=new e([o,a]);l.data=t.fft(r.data);let[s,c]=[o/i|0,a/i|0],u=n(l.data,[s,c]);return u.data=t.ifft(u.data),u}}function b(){return function(e){let t=9.109383*1e-30,n=1602177e-24,r=299792458;return 662607e-39/Math.sqrt(2*t*n*e)/Math.sqrt(1+n*e/2/t/r/r)*1e11}}function h(e){return function(t){let n=9.109383*1e-30,r=1602177e-24,i=299792458,o=e(t);return 2*Math.PI/o/t*(n*i*i+r*t)/(2*n*i*i+r*t)}}function w(e,t,n,r,i,o,a){return class{constructor(t,n,r,i,o){this._gpts=t.slice(),this._sampling=n.slice(),this._energy=r,this._wavelength=e(r),this._semiangle_cutoff=i,this._defocus=o}_get_scattering_angles(){let e=t(this._gpts[0],this._sampling[0]),o=t(this._gpts[1],this._sampling[1]),[a,l]=n(e,o);return[r.sqrt(r.add(a.multiply(a.multiply(this._wavelength*this._wavelength)),l.multiply(l.multiply(this._wavelength*this._wavelength)))),i(a,l)]}_evaluate_aberrations(e,t){let n=this._defocus/this._wavelength*Math.PI,i=e.multiply(e).multiply(n),a=r.cos(i),l=r.sin(i),s=new o(i.shape);return s.data=r.stack([a,l],-1),s}_evaluate_aperture(e,t){let n=this._semiangle_cutoff/1e3,i=new o(e.shape),l=a(e,n);return i.data=r.stack([l,r.zeros(e.shape)],-1),i}build(){let[e,t]=this._get_scattering_angles(),n=this._evaluate_aberrations(e,t),i=this._evaluate_aperture(e,t),a=n.multiply(i),l=new o(a.shape);l.data=r.ifft(a.data);let s=Math.sqrt(l.abs_sqr().sum());return this._array=l.scalar_multiply(1/s,0),this}}}function g(e,t){const n=e.module();return n.variable(t()).define(["md"],r),n.variable(t()).define(["htl"],i),n.variable(t("nj")).define("nj",["require"],o),n.variable(t("ops")).define("ops",["require"],a),n.variable(t("cops")).define("cops",["require"],l),n.variable(t("atan2")).define("atan2",["nj","ops"],s),n.variable(t("lt_int_s")).define("lt_int_s",["nj","ops"],c),n.variable(t("ComplexNDArray")).define("ComplexNDArray",["nj","atan2","cops"],u),n.variable(t("fftfreq")).define("fftfreq",["nj"],_),n.variable(t("meshgrid2D")).define("meshgrid2D",["nj"],f),n.variable(t("fftshift2D")).define("fftshift2D",["nj"],p),n.variable(t("fourier_shift")).define("fourier_shift",["ComplexNDArray","nj","fftfreq","meshgrid2D"],d),n.variable(t("corner_crop")).define("corner_crop",["ComplexNDArray"],v),n.variable(t("fourier_downsample")).define("fourier_downsample",["ComplexNDArray","nj","corner_crop"],m),n.variable(t("electron_wavelength_angstroms")).define("electron_wavelength_angstroms",b),n.variable(t("electron_interaction_parameter")).define("electron_interaction_parameter",["electron_wavelength_angstroms"],h),n.variable(t("ComplexProbe")).define("ComplexProbe",["electron_wavelength_angstroms","fftfreq","meshgrid2D","nj","atan2","ComplexNDArray","lt_int_s"],w),n}function x(e){return e`# Projection Set Algorithms

Here, we will illustrate another very powerful non-convex optimization strategy used in ptychograghy, called "projection set methods".`}function j(e){return e`## Alternating Projections

Suppose we want to find the solution at the intersection of two sets:
1. a set of all points lying on the red line, and
2. a set of all point lying on the blue line.

Seems simple right? The catch is that we're only allowed to operate on one set at a time. A simple idea could be to take alternating steps where we "project" on one of the sets.

_Note:_ By "project" here we mean finding the closest point between our current location that lies on the set.

Let's try it!`}function y(e){return e.range([50,1e3],{value:250,step:50,label:"Animation speed [ms]"})}function k(e){return e.toggle({label:"Iterate!"})}function P(e,t){return e.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[e.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:9/8,y:9/16,set:1,col:"red"},{x:-.5,y:-1/16,set:2,col:"blue"},{x:9/8,y:9/64,set:2,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),e.line(t,{stroke:"orange"}),e.dot(t,{fill:"orange",fillOpacity:.5,r:10})]})}function I(e){return e.button("Reset Initial Point")}function R(e){return e`## Non-Convex Sets?

The above example was rather easy, since both our sets were convex. What do you think will happen for non-convex sets? E.g. two disconnected half-lines. Well, our naive alternating projection algorithm will get stuck!`}function z(e){return e.toggle({label:"Iterate!"})}function A(e,t){return e.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[e.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),e.line(t,{stroke:"orange"}),e.dot(t,{fill:"orange",fillOpacity:.5,r:10})]})}function q(e){return e.button("Reset Initial Point")}function M(e){return e`## Generalized Projections

Turns out, we don't just have to "project" to the set exactly - we can also e.g. reflect about the set to allow for a wide search-space. More generally, we can define a "family" of generalized projection set algorithms according to the iteration:`}function D(e){return e.block`
x_{k+1} \leftarrow \left(1-a-b \right)x_k + a \Pi_1 \left[x_k\right] + b \Pi_2 \left[c \Pi[x_k]+\left(1-c\right)x_k \right]
`}function G(e,t){return t`For scalar parameters ${e`(a,b,c)`}.

Some named choices include:
- Alternating Projections (AP): ${e`(a=0,b=1,c=1)`}
- Difference Map (DM): ${e`(a=-1,b=1,c=2)`}
- Relax Reflect Reflect (RRR): ${e`(a=-\gamma,b=\gamma,c=2)`}
- Relaxed Averaged Alternating Reflections (RAAR): ${e`(a=1-2\gamma,b=\gamma,c=2)`}`}function N(e){return e.radio(["AP","DM","RRR","RAAR","Generalized"],{value:"AP",label:"Projection Name: "})}function C(e,t,n){return e.range([-1,1],{value:`${"Generalized"==t?0:n[t].a}`,step:.001,label:"Projection Parameter a"})}function $(e,t,n){return e.range([0,2],{value:`${"Generalized"==t?1:n[t].b}`,step:.001,label:"Projection Parameter b"})}function S(e,t,n){return e.range([0,2],{value:`${"Generalized"==t?1:n[t].c}`,step:.001,label:"Projection Parameter c"})}function E(e,t){return e.range([0,1],{value:""+("RRR"==t||"RAAR"==t?.875:0),step:.001,label:"Projection Parameter \u03b3"})}function T(e,t){return t`## Multiple Sets

In general, our algorithm above relies on only two generalized projections. When we have more than two sets, we need to reformulate our constraints in the form above. 

A simple way to do this is to apply our projections on a copy of the current iterate separately (${e`\Pi_1`} above), and then average our points together (${e`\Pi_2`} above).`}function V(e){return e.toggle({label:"Iterate!"})}function Z(e,t,n){let r=[...Array(e.shape[0])].map(((t,n)=>({x:e.get(n,0),y:e.get(n,1),set:5,col:"green"}))),i=t.map((e=>e.reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]])).map((t=>t/e.length))));return n.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[n.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"},...r],{x:"x",y:"y",z:"set",stroke:"col"}),n.line(i,{stroke:"orange"}),n.dot(i,{fill:"orange",fillOpacity:.5,r:10})]})}function O(e){return e.button("Reset Initial Point")}function L(e){return e.html`<hr class="hideable-md">`}function W(e){return{AP:{a:0,b:1,c:1},DM:{a:-1,b:1,c:2},RRR:{a:-e,b:e,c:2},RAAR:{a:1-2*e,b:e,c:2}}}function B(e){let t=e.arange(0,2*Math.PI,Math.PI/512),n=[-5/4*Math.cos(Math.PI/8),-5/4*Math.sin(Math.PI/8)],r=e.sin(t.multiply(4)).divide(4).add(1),i=r.multiply(e.cos(t)).subtract(n[0]).divide(3),o=r.multiply(e.sin(t)).subtract(n[1]).divide(3);return e.stack([i,o],-1)}function F(){return function([e,t]){return[.4*(2*e+t),(2*e+t)/5]}}function H(){return function([e,t]){return[32/65*(2*e+t/4),4/65*(2*e+t/4)]}}function U(){return function([e,t]){if(8*e+4*t>=5||2*e+t<=5/8){let n=(2*e+t)/5;return[2*n,n]}if(15/16<2*e+t&&2*e+t<5/4)return[.5,1/4];if(2*e+t>5/8)return[1/4,1/8];{let n=2*t/5+4*e/5-1/8;return[2*n,n]}}}function Y(){return function([e,t]){if(8*e+t>=65/16||8*e+t<=65/32){let n=(8*e+t)/65;return[8*n,n]}if(195/64<8*e+t&&e+t<65/16)return[.5,1/16];if(8*e+t>=65/32)return[1/4,1/32];{let n=2*t/65+16*e/64-1/32;return[8*n,n]}}}function J(e,t){return function([n,r]){let i=e.add(t.pick(null,0).subtract(n).pow(2),t.pick(null,1).subtract(r).pow(2)).tolist().reduce(((e,t,n,r)=>t>r[e]?e:n),-1);return[t.get(i,0),t.get(i,1)]}}function K(){return function(e,t,[n,r,i]){let o=1-n-r,a=1-i;return function([l,s]){let[c,u]=e([l,s]),[_,f]=t([i*c+a*l,i*u+a*s]);return[o*l+n*c+r*_,o*s+n*u+r*f]}}}function X(){return function(e,t,n){return function([[r,i],[o,a],[l,s]]){return[e([r,i]),t([o,a]),n([l,s])]}}}function Q(){return function([[e,t],[n,r],[i,o]]){let a=(e+n+i)/3,l=(t+r+o)/3;return[[a,l],[a,l],[a,l]]}}function ee(e,t){return function(n,r,i,[o,a,l]){let s=1-o-a,c=1-l,u=e(n,r,i),_=t;return function([[e,t],[n,r],[i,f]]){let[[p,d],[v,m],[b,h]]=u([[e,t],[n,r],[i,f]]),[[w,g],[x,j],[y,k]]=_([[l*p+c*e,l*d+c*t],[l*v+c*n,l*m+c*r],[l*b+c*i,l*h+c*f]]);return[[s*e+o*p+a*w,s*t+o*d+a*g],[s*n+o*v+a*x,s*r+o*m+a*j],[s*i+o*b+a*y,s*f+o*h+a*k]]}}}function te(e,t,n,r,i,o){return e(t,n,[r,i,o])}function ne(e,t,n,r,i,o){return e(t,n,[r,i,o])}function re(e,t,n,r,i,o,a){return e(t,n,r,[i,o,a])}function ie(){return[[1,.3]]}function oe(){return[[1,.3]]}function ae(){return[[[1,.3],[1,.3],[1,.3]]]}function le(e,t){t.value=[[1,.3]]}function*se(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function ce(e,t){t.value=[[1,.3]]}function*ue(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function _e(e,t){t.value=[[[1,.3],[1,.3],[1,.3]]]}function*fe(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function pe(e,t){const n=e.module();n.variable(t()).define(["md"],x),n.variable(t()).define(["md"],j),n.variable(t("viewof animation_speed")).define("viewof animation_speed",["Inputs"],y),n.variable(t("animation_speed")).define("animation_speed",["Generators","viewof animation_speed"],((e,t)=>e.input(t))),n.variable(t("viewof iterate_convex")).define("viewof iterate_convex",["Inputs"],k),n.variable(t("iterate_convex")).define("iterate_convex",["Generators","viewof iterate_convex"],((e,t)=>e.input(t))),n.variable(t("two_convex_sets_plot")).define("two_convex_sets_plot",["Plot","iteration_pts_convex"],P),n.variable(t("viewof reset_convex")).define("viewof reset_convex",["Inputs"],I),n.variable(t("reset_convex")).define("reset_convex",["Generators","viewof reset_convex"],((e,t)=>e.input(t))),n.variable(t()).define(["md"],R),n.variable(t("viewof iterate_nonconvex")).define("viewof iterate_nonconvex",["Inputs"],z),n.variable(t("iterate_nonconvex")).define("iterate_nonconvex",["Generators","viewof iterate_nonconvex"],((e,t)=>e.input(t))),n.variable(t("two_nonconvex_sets_plot")).define("two_nonconvex_sets_plot",["Plot","iteration_pts_nonconvex"],A),n.variable(t("viewof reset_nonconvex")).define("viewof reset_nonconvex",["Inputs"],q),n.variable(t("reset_nonconvex")).define("reset_nonconvex",["Generators","viewof reset_nonconvex"],((e,t)=>e.input(t))),n.variable(t()).define(["md"],M),n.variable(t()).define(["tex"],D),n.variable(t()).define(["tex","md"],G),n.variable(t("viewof projection_name")).define("viewof projection_name",["Inputs"],N),n.variable(t("projection_name")).define("projection_name",["Generators","viewof projection_name"],((e,t)=>e.input(t))),n.variable(t("viewof projection_a")).define("viewof projection_a",["Inputs","projection_name","named_projection_parameters"],C),n.variable(t("projection_a")).define("projection_a",["Generators","viewof projection_a"],((e,t)=>e.input(t))),n.variable(t("viewof projection_b")).define("viewof projection_b",["Inputs","projection_name","named_projection_parameters"],$),n.variable(t("projection_b")).define("projection_b",["Generators","viewof projection_b"],((e,t)=>e.input(t))),n.variable(t("viewof projection_c")).define("viewof projection_c",["Inputs","projection_name","named_projection_parameters"],S),n.variable(t("projection_c")).define("projection_c",["Generators","viewof projection_c"],((e,t)=>e.input(t))),n.variable(t("viewof projection_gamma")).define("viewof projection_gamma",["Inputs","projection_name"],E),n.variable(t("projection_gamma")).define("projection_gamma",["Generators","viewof projection_gamma"],((e,t)=>e.input(t))),n.variable(t()).define(["tex","md"],T),n.variable(t("viewof iterate_flower")).define("viewof iterate_flower",["Inputs"],V),n.variable(t("iterate_flower")).define("iterate_flower",["Generators","viewof iterate_flower"],((e,t)=>e.input(t))),n.variable(t("flower_sets_plot")).define("flower_sets_plot",["flower_values","iteration_pts_flower","Plot"],Z),n.variable(t("viewof reset_flower")).define("viewof reset_flower",["Inputs"],O),n.variable(t("reset_flower")).define("reset_flower",["Generators","viewof reset_flower"],((e,t)=>e.input(t))),n.variable(t()).define(["htl"],L);const r=e.module(g);return n.import("nj",r),n.variable(t("named_projection_parameters")).define("named_projection_parameters",["projection_gamma"],W),n.variable(t("flower_values")).define("flower_values",["nj"],B),n.variable(t("region_nearest_convex_red")).define("region_nearest_convex_red",F),n.variable(t("region_nearest_convex_blue")).define("region_nearest_convex_blue",H),n.variable(t("region_nearest_nonconvex_red")).define("region_nearest_nonconvex_red",U),n.variable(t("region_nearest_nonconvex_blue")).define("region_nearest_nonconvex_blue",Y),n.variable(t("region_nearest_flower_green")).define("region_nearest_flower_green",["nj","flower_values"],J),n.variable(t("generalized_projection")).define("generalized_projection",K),n.variable(t("product_space_projection")).define("product_space_projection",X),n.variable(t("diagonal_projection")).define("diagonal_projection",Q),n.variable(t("generalized_projection_multiple")).define("generalized_projection_multiple",["product_space_projection","diagonal_projection"],ee),n.variable(t("two_convex_sets")).define("two_convex_sets",["generalized_projection","region_nearest_convex_red","region_nearest_convex_blue","projection_a","projection_b","projection_c"],te),n.variable(t("two_nonconvex_sets")).define("two_nonconvex_sets",["generalized_projection","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","projection_a","projection_b","projection_c"],ne),n.variable(t("three_nonconvex_sets")).define("three_nonconvex_sets",["generalized_projection_multiple","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","region_nearest_flower_green","projection_a","projection_b","projection_c"],re),n.define("initial iteration_pts_convex",ie),n.variable(t("mutable iteration_pts_convex")).define("mutable iteration_pts_convex",["Mutable","initial iteration_pts_convex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_convex")).define("iteration_pts_convex",["mutable iteration_pts_convex"],(e=>e.generator)),n.define("initial iteration_pts_nonconvex",oe),n.variable(t("mutable iteration_pts_nonconvex")).define("mutable iteration_pts_nonconvex",["Mutable","initial iteration_pts_nonconvex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_nonconvex")).define("iteration_pts_nonconvex",["mutable iteration_pts_nonconvex"],(e=>e.generator)),n.define("initial iteration_pts_flower",ae),n.variable(t("mutable iteration_pts_flower")).define("mutable iteration_pts_flower",["Mutable","initial iteration_pts_flower"],((e,t)=>new e(t))),n.variable(t("iteration_pts_flower")).define("iteration_pts_flower",["mutable iteration_pts_flower"],(e=>e.generator)),n.variable(t("two_convex_sets_reset")).define("two_convex_sets_reset",["reset_convex","mutable iteration_pts_convex"],le),n.variable(t("two_convex_sets_generator")).define("two_convex_sets_generator",["iterate_convex","Promises","animation_speed","iteration_pts_convex","mutable iteration_pts_convex","two_convex_sets"],se),n.variable(t("two_nonconvex_sets_reset")).define("two_nonconvex_sets_reset",["reset_nonconvex","mutable iteration_pts_nonconvex"],ce),n.variable(t("two_nonconvex_sets_generator")).define("two_nonconvex_sets_generator",["iterate_nonconvex","Promises","animation_speed","iteration_pts_nonconvex","mutable iteration_pts_nonconvex","two_nonconvex_sets"],ue),n.variable(t("flower_sets_reset")).define("flower_sets_reset",["reset_flower","mutable iteration_pts_flower"],_e),n.variable(t("flower_sets_generator")).define("flower_sets_generator",["iterate_flower","Promises","animation_speed","iteration_pts_flower","mutable iteration_pts_flower","three_nonconvex_sets"],fe),n}function de(e){return e}function ve(e){return e}function me(e){return e}function be(e){return e}function he(e){return e}function we(e){return e}function ge(e){return e}function xe(e){return e}function je(e){return e}function ye(e){return e.html`<hr class="hideable-md">`}function ke(e){return e}function Pe(e){return e}function Ie(e,t){const n=e.module();n.variable(t()).define(["viewof animation_speed"],de),n.variable(t()).define(["viewof iterate_flower"],ve),n.variable(t()).define(["flower_sets_plot"],me),n.variable(t()).define(["viewof reset_flower"],be),n.variable(t()).define(["viewof projection_name"],he),n.variable(t()).define(["viewof projection_a"],we),n.variable(t()).define(["viewof projection_b"],ge),n.variable(t()).define(["viewof projection_c"],xe),n.variable(t()).define(["viewof projection_gamma"],je),n.variable(t()).define(["htl"],ye);const r=e.module(pe);return n.import("viewof animation_speed",r),n.import("animation_speed",r),n.import("viewof iterate_flower",r),n.import("iterate_flower",r),n.import("viewof reset_flower",r),n.import("reset_flower",r),n.import("flower_sets_plot",r),n.import("flower_sets_generator",r),n.import("flower_sets_reset",r),n.import("viewof projection_name",r),n.import("projection_name",r),n.import("viewof projection_a",r),n.import("projection_a",r),n.import("viewof projection_b",r),n.import("projection_b",r),n.import("viewof projection_c",r),n.import("projection_c",r),n.import("viewof projection_gamma",r),n.import("projection_gamma",r),n.variable(t()).define(["flower_sets_generator"],ke),n.variable(t()).define(["flower_sets_reset"],Pe),n}n.d(t,{Z:()=>Ie})},7188:(e,t,n)=>{function r(e){return e`# Ptychography Helper Functions`}function i(e){return e.html`<hr class="hideable-md">`}function o(e){return e("https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.16/dist/numjs.min.js")}function a(e){return e("https://bundle.run/ndarray-ops@1.2.2")}function l(e){return e("https://bundle.run/ndarray-complex@1.0.3")}function s(e,t){return function(n,r){let i=e.zeros(n.shape);return t.atan2(i.selection,n.selection,r.selection),i}}function c(e,t){return function(n,r){let i=e.zeros(n.shape);return t.lts(i.selection,n.selection,r),t.bandseq(i.selection,1),i}}function u(e,t,n){return class r{constructor(t){this.shape=t;let n=t.slice();n.push(2),this.data=e.zeros(n),this._nulls=new Array(t.length).fill(null)}re(){return this.data.pick(...this._nulls,0)}im(){return this.data.pick(...this._nulls,1)}abs(){return e.sqrt(this.abs_sqr())}abs_sqr(){return e.add(this.re().multiply(this.re()),this.im().multiply(this.im()))}angle(){return t(this.im(),this.re())}clone(){let e=new r(this.shape);return e.data=this.data.clone(),e}conjugate(){let t=this.re().clone(),i=this.im().clone();n.conjeq(t.selection,i.selection);let o=new r(this.shape);return o.data=e.stack([t,i],-1),o}multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}real_multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t,l=e.zeros(t.shape);n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}scalar_multiply(t,i){let o=this.re().clone(),a=this.im().clone();n.mulseq(o.selection,a.selection,t,i);let l=new r(this.shape);return l.data=e.stack([o,a],-1),l}add(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.addeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}subtract(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.subeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}}}function _(e){return function(t,n){let r=e.zeros(t),i=1/(t*n),o=1+((t-1)/2|0);for(var a=0;a<o;a++)r.set(a,a*i);for(a=o;a<t;a++)r.set(a,(a-t)*i);return r}}function f(e){return function(t,n){let r=[t.size,n.size],i=[];i[0]=e.zeros(r),i[1]=e.zeros(r);for(let e=0;e<r[1];e++)for(let o=0;o<r[0];o++)i[0].set(o,e,t.get(o)),i[1].set(o,e,n.get(e));return i}}function p(e){return function(t){let[n,r]=t.shape,i=n/2|0,o=r/2|0,a=e.zeros([n,r]);return a.slice([null,i],[null,o]).assign(t.slice(-i,-o),!1),a.slice([null,i],o).assign(t.slice(-i,[null,o]),!1),a.slice(-i,-o).assign(t.slice([null,i],[null,o]),!1),a.slice(-i,[null,o]).assign(t.slice([null,i],-o),!1),a}}function d(e,t,n,r){return function(i,o){let[a,l]=i.shape,[s,c]=o,u=new e([a,l]);u.data=t.fft(i.data);let _=n(a,1),f=n(l,1),[p,d]=r(_,f),v=-2*Math.PI,m=t.add(p.multiply(s),d.multiply(c)).multiply(v),b=new e([a,l]),h=t.cos(m),w=t.sin(m);b.data=t.stack([h,w],-1);let g=u.multiply(b);return g.data=t.ifft(g.data),g}}function v(e){return function(t,[n,r]){let i=new e([n,r]),o=n/2|0,a=r/2|0;return i.data.slice([null,o],[null,a],null).assign(t.slice([null,o],[null,a],null),!1),i.data.slice(-o,[null,a],null).assign(t.slice(-o,[null,a],null),!1),i.data.slice([null,o],-a,null).assign(t.slice([null,o],-a,null),!1),i.data.slice(-o,-a,null).assign(t.slice(-o,-a,null),!1),i}}function m(e,t,n){return function(r,i){let[o,a]=r.shape;console.log(o);let l=new e([o,a]);l.data=t.fft(r.data);let[s,c]=[o/i|0,a/i|0],u=n(l.data,[s,c]);return u.data=t.ifft(u.data),u}}function b(){return function(e){let t=9.109383*1e-30,n=1602177e-24,r=299792458;return 662607e-39/Math.sqrt(2*t*n*e)/Math.sqrt(1+n*e/2/t/r/r)*1e11}}function h(e){return function(t){let n=9.109383*1e-30,r=1602177e-24,i=299792458,o=e(t);return 2*Math.PI/o/t*(n*i*i+r*t)/(2*n*i*i+r*t)}}function w(e,t,n,r,i,o,a){return class{constructor(t,n,r,i,o){this._gpts=t.slice(),this._sampling=n.slice(),this._energy=r,this._wavelength=e(r),this._semiangle_cutoff=i,this._defocus=o}_get_scattering_angles(){let e=t(this._gpts[0],this._sampling[0]),o=t(this._gpts[1],this._sampling[1]),[a,l]=n(e,o);return[r.sqrt(r.add(a.multiply(a.multiply(this._wavelength*this._wavelength)),l.multiply(l.multiply(this._wavelength*this._wavelength)))),i(a,l)]}_evaluate_aberrations(e,t){let n=this._defocus/this._wavelength*Math.PI,i=e.multiply(e).multiply(n),a=r.cos(i),l=r.sin(i),s=new o(i.shape);return s.data=r.stack([a,l],-1),s}_evaluate_aperture(e,t){let n=this._semiangle_cutoff/1e3,i=new o(e.shape),l=a(e,n);return i.data=r.stack([l,r.zeros(e.shape)],-1),i}build(){let[e,t]=this._get_scattering_angles(),n=this._evaluate_aberrations(e,t),i=this._evaluate_aperture(e,t),a=n.multiply(i),l=new o(a.shape);l.data=r.ifft(a.data);let s=Math.sqrt(l.abs_sqr().sum());return this._array=l.scalar_multiply(1/s,0),this}}}function g(e,t){const n=e.module();return n.variable(t()).define(["md"],r),n.variable(t()).define(["htl"],i),n.variable(t("nj")).define("nj",["require"],o),n.variable(t("ops")).define("ops",["require"],a),n.variable(t("cops")).define("cops",["require"],l),n.variable(t("atan2")).define("atan2",["nj","ops"],s),n.variable(t("lt_int_s")).define("lt_int_s",["nj","ops"],c),n.variable(t("ComplexNDArray")).define("ComplexNDArray",["nj","atan2","cops"],u),n.variable(t("fftfreq")).define("fftfreq",["nj"],_),n.variable(t("meshgrid2D")).define("meshgrid2D",["nj"],f),n.variable(t("fftshift2D")).define("fftshift2D",["nj"],p),n.variable(t("fourier_shift")).define("fourier_shift",["ComplexNDArray","nj","fftfreq","meshgrid2D"],d),n.variable(t("corner_crop")).define("corner_crop",["ComplexNDArray"],v),n.variable(t("fourier_downsample")).define("fourier_downsample",["ComplexNDArray","nj","corner_crop"],m),n.variable(t("electron_wavelength_angstroms")).define("electron_wavelength_angstroms",b),n.variable(t("electron_interaction_parameter")).define("electron_interaction_parameter",["electron_wavelength_angstroms"],h),n.variable(t("ComplexProbe")).define("ComplexProbe",["electron_wavelength_angstroms","fftfreq","meshgrid2D","nj","atan2","ComplexNDArray","lt_int_s"],w),n}function x(e){return e`# Projection Set Algorithms

Here, we will illustrate another very powerful non-convex optimization strategy used in ptychograghy, called "projection set methods".`}function j(e){return e`## Alternating Projections

Suppose we want to find the solution at the intersection of two sets:
1. a set of all points lying on the red line, and
2. a set of all point lying on the blue line.

Seems simple right? The catch is that we're only allowed to operate on one set at a time. A simple idea could be to take alternating steps where we "project" on one of the sets.

_Note:_ By "project" here we mean finding the closest point between our current location that lies on the set.

Let's try it!`}function y(e){return e.range([50,1e3],{value:250,step:50,label:"Animation speed [ms]"})}function k(e){return e.toggle({label:"Iterate!"})}function P(e,t){return e.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[e.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:9/8,y:9/16,set:1,col:"red"},{x:-.5,y:-1/16,set:2,col:"blue"},{x:9/8,y:9/64,set:2,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),e.line(t,{stroke:"orange"}),e.dot(t,{fill:"orange",fillOpacity:.5,r:10})]})}function I(e){return e.button("Reset Initial Point")}function R(e){return e`## Non-Convex Sets?

The above example was rather easy, since both our sets were convex. What do you think will happen for non-convex sets? E.g. two disconnected half-lines. Well, our naive alternating projection algorithm will get stuck!`}function z(e){return e.toggle({label:"Iterate!"})}function A(e,t){return e.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[e.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),e.line(t,{stroke:"orange"}),e.dot(t,{fill:"orange",fillOpacity:.5,r:10})]})}function q(e){return e.button("Reset Initial Point")}function M(e){return e`## Generalized Projections

Turns out, we don't just have to "project" to the set exactly - we can also e.g. reflect about the set to allow for a wide search-space. More generally, we can define a "family" of generalized projection set algorithms according to the iteration:`}function D(e){return e.block`
x_{k+1} \leftarrow \left(1-a-b \right)x_k + a \Pi_1 \left[x_k\right] + b \Pi_2 \left[c \Pi[x_k]+\left(1-c\right)x_k \right]
`}function G(e,t){return t`For scalar parameters ${e`(a,b,c)`}.

Some named choices include:
- Alternating Projections (AP): ${e`(a=0,b=1,c=1)`}
- Difference Map (DM): ${e`(a=-1,b=1,c=2)`}
- Relax Reflect Reflect (RRR): ${e`(a=-\gamma,b=\gamma,c=2)`}
- Relaxed Averaged Alternating Reflections (RAAR): ${e`(a=1-2\gamma,b=\gamma,c=2)`}`}function N(e){return e.radio(["AP","DM","RRR","RAAR","Generalized"],{value:"AP",label:"Projection Name: "})}function C(e,t,n){return e.range([-1,1],{value:`${"Generalized"==t?0:n[t].a}`,step:.001,label:"Projection Parameter a"})}function $(e,t,n){return e.range([0,2],{value:`${"Generalized"==t?1:n[t].b}`,step:.001,label:"Projection Parameter b"})}function S(e,t,n){return e.range([0,2],{value:`${"Generalized"==t?1:n[t].c}`,step:.001,label:"Projection Parameter c"})}function E(e,t){return e.range([0,1],{value:""+("RRR"==t||"RAAR"==t?.875:0),step:.001,label:"Projection Parameter \u03b3"})}function T(e,t){return t`## Multiple Sets

In general, our algorithm above relies on only two generalized projections. When we have more than two sets, we need to reformulate our constraints in the form above. 

A simple way to do this is to apply our projections on a copy of the current iterate separately (${e`\Pi_1`} above), and then average our points together (${e`\Pi_2`} above).`}function V(e){return e.toggle({label:"Iterate!"})}function Z(e,t,n){let r=[...Array(e.shape[0])].map(((t,n)=>({x:e.get(n,0),y:e.get(n,1),set:5,col:"green"}))),i=t.map((e=>e.reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]])).map((t=>t/e.length))));return n.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[n.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"},...r],{x:"x",y:"y",z:"set",stroke:"col"}),n.line(i,{stroke:"orange"}),n.dot(i,{fill:"orange",fillOpacity:.5,r:10})]})}function O(e){return e.button("Reset Initial Point")}function L(e){return e.html`<hr class="hideable-md">`}function W(e){return{AP:{a:0,b:1,c:1},DM:{a:-1,b:1,c:2},RRR:{a:-e,b:e,c:2},RAAR:{a:1-2*e,b:e,c:2}}}function B(e){let t=e.arange(0,2*Math.PI,Math.PI/512),n=[-5/4*Math.cos(Math.PI/8),-5/4*Math.sin(Math.PI/8)],r=e.sin(t.multiply(4)).divide(4).add(1),i=r.multiply(e.cos(t)).subtract(n[0]).divide(3),o=r.multiply(e.sin(t)).subtract(n[1]).divide(3);return e.stack([i,o],-1)}function F(){return function([e,t]){return[.4*(2*e+t),(2*e+t)/5]}}function H(){return function([e,t]){return[32/65*(2*e+t/4),4/65*(2*e+t/4)]}}function U(){return function([e,t]){if(8*e+4*t>=5||2*e+t<=5/8){let n=(2*e+t)/5;return[2*n,n]}if(15/16<2*e+t&&2*e+t<5/4)return[.5,1/4];if(2*e+t>5/8)return[1/4,1/8];{let n=2*t/5+4*e/5-1/8;return[2*n,n]}}}function Y(){return function([e,t]){if(8*e+t>=65/16||8*e+t<=65/32){let n=(8*e+t)/65;return[8*n,n]}if(195/64<8*e+t&&e+t<65/16)return[.5,1/16];if(8*e+t>=65/32)return[1/4,1/32];{let n=2*t/65+16*e/64-1/32;return[8*n,n]}}}function J(e,t){return function([n,r]){let i=e.add(t.pick(null,0).subtract(n).pow(2),t.pick(null,1).subtract(r).pow(2)).tolist().reduce(((e,t,n,r)=>t>r[e]?e:n),-1);return[t.get(i,0),t.get(i,1)]}}function K(){return function(e,t,[n,r,i]){let o=1-n-r,a=1-i;return function([l,s]){let[c,u]=e([l,s]),[_,f]=t([i*c+a*l,i*u+a*s]);return[o*l+n*c+r*_,o*s+n*u+r*f]}}}function X(){return function(e,t,n){return function([[r,i],[o,a],[l,s]]){return[e([r,i]),t([o,a]),n([l,s])]}}}function Q(){return function([[e,t],[n,r],[i,o]]){let a=(e+n+i)/3,l=(t+r+o)/3;return[[a,l],[a,l],[a,l]]}}function ee(e,t){return function(n,r,i,[o,a,l]){let s=1-o-a,c=1-l,u=e(n,r,i),_=t;return function([[e,t],[n,r],[i,f]]){let[[p,d],[v,m],[b,h]]=u([[e,t],[n,r],[i,f]]),[[w,g],[x,j],[y,k]]=_([[l*p+c*e,l*d+c*t],[l*v+c*n,l*m+c*r],[l*b+c*i,l*h+c*f]]);return[[s*e+o*p+a*w,s*t+o*d+a*g],[s*n+o*v+a*x,s*r+o*m+a*j],[s*i+o*b+a*y,s*f+o*h+a*k]]}}}function te(e,t,n,r,i,o){return e(t,n,[r,i,o])}function ne(e,t,n,r,i,o){return e(t,n,[r,i,o])}function re(e,t,n,r,i,o,a){return e(t,n,r,[i,o,a])}function ie(){return[[1,.3]]}function oe(){return[[1,.3]]}function ae(){return[[[1,.3],[1,.3],[1,.3]]]}function le(e,t){t.value=[[1,.3]]}function*se(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function ce(e,t){t.value=[[1,.3]]}function*ue(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function _e(e,t){t.value=[[[1,.3],[1,.3],[1,.3]]]}function*fe(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function pe(e,t){const n=e.module();n.variable(t()).define(["md"],x),n.variable(t()).define(["md"],j),n.variable(t("viewof animation_speed")).define("viewof animation_speed",["Inputs"],y),n.variable(t("animation_speed")).define("animation_speed",["Generators","viewof animation_speed"],((e,t)=>e.input(t))),n.variable(t("viewof iterate_convex")).define("viewof iterate_convex",["Inputs"],k),n.variable(t("iterate_convex")).define("iterate_convex",["Generators","viewof iterate_convex"],((e,t)=>e.input(t))),n.variable(t("two_convex_sets_plot")).define("two_convex_sets_plot",["Plot","iteration_pts_convex"],P),n.variable(t("viewof reset_convex")).define("viewof reset_convex",["Inputs"],I),n.variable(t("reset_convex")).define("reset_convex",["Generators","viewof reset_convex"],((e,t)=>e.input(t))),n.variable(t()).define(["md"],R),n.variable(t("viewof iterate_nonconvex")).define("viewof iterate_nonconvex",["Inputs"],z),n.variable(t("iterate_nonconvex")).define("iterate_nonconvex",["Generators","viewof iterate_nonconvex"],((e,t)=>e.input(t))),n.variable(t()).define(["Plot","iteration_pts_nonconvex"],A),n.variable(t("viewof reset_nonconvex")).define("viewof reset_nonconvex",["Inputs"],q),n.variable(t("reset_nonconvex")).define("reset_nonconvex",["Generators","viewof reset_nonconvex"],((e,t)=>e.input(t))),n.variable(t()).define(["md"],M),n.variable(t()).define(["tex"],D),n.variable(t()).define(["tex","md"],G),n.variable(t("viewof projection_name")).define("viewof projection_name",["Inputs"],N),n.variable(t("projection_name")).define("projection_name",["Generators","viewof projection_name"],((e,t)=>e.input(t))),n.variable(t("viewof projection_a")).define("viewof projection_a",["Inputs","projection_name","named_projection_parameters"],C),n.variable(t("projection_a")).define("projection_a",["Generators","viewof projection_a"],((e,t)=>e.input(t))),n.variable(t("viewof projection_b")).define("viewof projection_b",["Inputs","projection_name","named_projection_parameters"],$),n.variable(t("projection_b")).define("projection_b",["Generators","viewof projection_b"],((e,t)=>e.input(t))),n.variable(t("viewof projection_c")).define("viewof projection_c",["Inputs","projection_name","named_projection_parameters"],S),n.variable(t("projection_c")).define("projection_c",["Generators","viewof projection_c"],((e,t)=>e.input(t))),n.variable(t("viewof projection_gamma")).define("viewof projection_gamma",["Inputs","projection_name"],E),n.variable(t("projection_gamma")).define("projection_gamma",["Generators","viewof projection_gamma"],((e,t)=>e.input(t))),n.variable(t()).define(["tex","md"],T),n.variable(t("viewof iterate_flower")).define("viewof iterate_flower",["Inputs"],V),n.variable(t("iterate_flower")).define("iterate_flower",["Generators","viewof iterate_flower"],((e,t)=>e.input(t))),n.variable(t()).define(["flower_values","iteration_pts_flower","Plot"],Z),n.variable(t("viewof reset_flower")).define("viewof reset_flower",["Inputs"],O),n.variable(t("reset_flower")).define("reset_flower",["Generators","viewof reset_flower"],((e,t)=>e.input(t))),n.variable(t()).define(["htl"],L);const r=e.module(g);return n.import("nj",r),n.variable(t("named_projection_parameters")).define("named_projection_parameters",["projection_gamma"],W),n.variable(t("flower_values")).define("flower_values",["nj"],B),n.variable(t("region_nearest_convex_red")).define("region_nearest_convex_red",F),n.variable(t("region_nearest_convex_blue")).define("region_nearest_convex_blue",H),n.variable(t("region_nearest_nonconvex_red")).define("region_nearest_nonconvex_red",U),n.variable(t("region_nearest_nonconvex_blue")).define("region_nearest_nonconvex_blue",Y),n.variable(t("region_nearest_flower_green")).define("region_nearest_flower_green",["nj","flower_values"],J),n.variable(t("generalized_projection")).define("generalized_projection",K),n.variable(t("product_space_projection")).define("product_space_projection",X),n.variable(t("diagonal_projection")).define("diagonal_projection",Q),n.variable(t("generalized_projection_multiple")).define("generalized_projection_multiple",["product_space_projection","diagonal_projection"],ee),n.variable(t("two_convex_sets")).define("two_convex_sets",["generalized_projection","region_nearest_convex_red","region_nearest_convex_blue","projection_a","projection_b","projection_c"],te),n.variable(t("two_nonconvex_sets")).define("two_nonconvex_sets",["generalized_projection","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","projection_a","projection_b","projection_c"],ne),n.variable(t("three_nonconvex_sets")).define("three_nonconvex_sets",["generalized_projection_multiple","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","region_nearest_flower_green","projection_a","projection_b","projection_c"],re),n.define("initial iteration_pts_convex",ie),n.variable(t("mutable iteration_pts_convex")).define("mutable iteration_pts_convex",["Mutable","initial iteration_pts_convex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_convex")).define("iteration_pts_convex",["mutable iteration_pts_convex"],(e=>e.generator)),n.define("initial iteration_pts_nonconvex",oe),n.variable(t("mutable iteration_pts_nonconvex")).define("mutable iteration_pts_nonconvex",["Mutable","initial iteration_pts_nonconvex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_nonconvex")).define("iteration_pts_nonconvex",["mutable iteration_pts_nonconvex"],(e=>e.generator)),n.define("initial iteration_pts_flower",ae),n.variable(t("mutable iteration_pts_flower")).define("mutable iteration_pts_flower",["Mutable","initial iteration_pts_flower"],((e,t)=>new e(t))),n.variable(t("iteration_pts_flower")).define("iteration_pts_flower",["mutable iteration_pts_flower"],(e=>e.generator)),n.variable(t("two_convex_sets_reset")).define("two_convex_sets_reset",["reset_convex","mutable iteration_pts_convex"],le),n.variable(t("two_convex_sets_generator")).define("two_convex_sets_generator",["iterate_convex","Promises","animation_speed","iteration_pts_convex","mutable iteration_pts_convex","two_convex_sets"],se),n.variable(t()).define(["reset_nonconvex","mutable iteration_pts_nonconvex"],ce),n.variable(t()).define(["iterate_nonconvex","Promises","animation_speed","iteration_pts_nonconvex","mutable iteration_pts_nonconvex","two_nonconvex_sets"],ue),n.variable(t()).define(["reset_flower","mutable iteration_pts_flower"],_e),n.variable(t()).define(["iterate_flower","Promises","animation_speed","iteration_pts_flower","mutable iteration_pts_flower","three_nonconvex_sets"],fe),n}function de(e){return e}function ve(e){return e}function me(e){return e}function be(e){return e}function he(e){return e.html`<hr class="hideable-md">`}function we(e){return e}function ge(e){return e}function xe(e,t){const n=e.module();n.variable(t()).define(["viewof animation_speed"],de),n.variable(t()).define(["viewof iterate_convex"],ve),n.variable(t()).define(["two_convex_sets_plot"],me),n.variable(t()).define(["viewof reset_convex"],be),n.variable(t()).define(["htl"],he);const r=e.module(pe);return n.import("viewof animation_speed",r),n.import("animation_speed",r),n.import("viewof iterate_convex",r),n.import("iterate_convex",r),n.import("viewof reset_convex",r),n.import("reset_convex",r),n.import("two_convex_sets_plot",r),n.import("two_convex_sets_generator",r),n.import("two_convex_sets_reset",r),n.variable(t()).define(["two_convex_sets_generator"],we),n.variable(t()).define(["two_convex_sets_reset"],ge),n}n.d(t,{Z:()=>xe})},7109:(e,t,n)=>{function r(e){return e`# Ptychography Helper Functions`}function i(e){return e.html`<hr class="hideable-md">`}function o(e){return e("https://cdn.jsdelivr.net/gh/nicolaspanel/numjs@0.16/dist/numjs.min.js")}function a(e){return e("https://bundle.run/ndarray-ops@1.2.2")}function l(e){return e("https://bundle.run/ndarray-complex@1.0.3")}function s(e,t){return function(n,r){let i=e.zeros(n.shape);return t.atan2(i.selection,n.selection,r.selection),i}}function c(e,t){return function(n,r){let i=e.zeros(n.shape);return t.lts(i.selection,n.selection,r),t.bandseq(i.selection,1),i}}function u(e,t,n){return class r{constructor(t){this.shape=t;let n=t.slice();n.push(2),this.data=e.zeros(n),this._nulls=new Array(t.length).fill(null)}re(){return this.data.pick(...this._nulls,0)}im(){return this.data.pick(...this._nulls,1)}abs(){return e.sqrt(this.abs_sqr())}abs_sqr(){return e.add(this.re().multiply(this.re()),this.im().multiply(this.im()))}angle(){return t(this.im(),this.re())}clone(){let e=new r(this.shape);return e.data=this.data.clone(),e}conjugate(){let t=this.re().clone(),i=this.im().clone();n.conjeq(t.selection,i.selection);let o=new r(this.shape);return o.data=e.stack([t,i],-1),o}multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}real_multiply(t){let i=this.re().clone(),o=this.im().clone(),a=t,l=e.zeros(t.shape);n.muleq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}scalar_multiply(t,i){let o=this.re().clone(),a=this.im().clone();n.mulseq(o.selection,a.selection,t,i);let l=new r(this.shape);return l.data=e.stack([o,a],-1),l}add(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.addeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}subtract(t){let i=this.re().clone(),o=this.im().clone(),a=t.re(),l=t.im();n.subeq(i.selection,o.selection,a.selection,l.selection);let s=new r(this.shape);return s.data=e.stack([i,o],-1),s}}}function _(e){return function(t,n){let r=e.zeros(t),i=1/(t*n),o=1+((t-1)/2|0);for(var a=0;a<o;a++)r.set(a,a*i);for(a=o;a<t;a++)r.set(a,(a-t)*i);return r}}function f(e){return function(t,n){let r=[t.size,n.size],i=[];i[0]=e.zeros(r),i[1]=e.zeros(r);for(let e=0;e<r[1];e++)for(let o=0;o<r[0];o++)i[0].set(o,e,t.get(o)),i[1].set(o,e,n.get(e));return i}}function p(e){return function(t){let[n,r]=t.shape,i=n/2|0,o=r/2|0,a=e.zeros([n,r]);return a.slice([null,i],[null,o]).assign(t.slice(-i,-o),!1),a.slice([null,i],o).assign(t.slice(-i,[null,o]),!1),a.slice(-i,-o).assign(t.slice([null,i],[null,o]),!1),a.slice(-i,[null,o]).assign(t.slice([null,i],-o),!1),a}}function d(e,t,n,r){return function(i,o){let[a,l]=i.shape,[s,c]=o,u=new e([a,l]);u.data=t.fft(i.data);let _=n(a,1),f=n(l,1),[p,d]=r(_,f),v=-2*Math.PI,m=t.add(p.multiply(s),d.multiply(c)).multiply(v),b=new e([a,l]),h=t.cos(m),w=t.sin(m);b.data=t.stack([h,w],-1);let g=u.multiply(b);return g.data=t.ifft(g.data),g}}function v(e){return function(t,[n,r]){let i=new e([n,r]),o=n/2|0,a=r/2|0;return i.data.slice([null,o],[null,a],null).assign(t.slice([null,o],[null,a],null),!1),i.data.slice(-o,[null,a],null).assign(t.slice(-o,[null,a],null),!1),i.data.slice([null,o],-a,null).assign(t.slice([null,o],-a,null),!1),i.data.slice(-o,-a,null).assign(t.slice(-o,-a,null),!1),i}}function m(e,t,n){return function(r,i){let[o,a]=r.shape;console.log(o);let l=new e([o,a]);l.data=t.fft(r.data);let[s,c]=[o/i|0,a/i|0],u=n(l.data,[s,c]);return u.data=t.ifft(u.data),u}}function b(){return function(e){let t=9.109383*1e-30,n=1602177e-24,r=299792458;return 662607e-39/Math.sqrt(2*t*n*e)/Math.sqrt(1+n*e/2/t/r/r)*1e11}}function h(e){return function(t){let n=9.109383*1e-30,r=1602177e-24,i=299792458,o=e(t);return 2*Math.PI/o/t*(n*i*i+r*t)/(2*n*i*i+r*t)}}function w(e,t,n,r,i,o,a){return class{constructor(t,n,r,i,o){this._gpts=t.slice(),this._sampling=n.slice(),this._energy=r,this._wavelength=e(r),this._semiangle_cutoff=i,this._defocus=o}_get_scattering_angles(){let e=t(this._gpts[0],this._sampling[0]),o=t(this._gpts[1],this._sampling[1]),[a,l]=n(e,o);return[r.sqrt(r.add(a.multiply(a.multiply(this._wavelength*this._wavelength)),l.multiply(l.multiply(this._wavelength*this._wavelength)))),i(a,l)]}_evaluate_aberrations(e,t){let n=this._defocus/this._wavelength*Math.PI,i=e.multiply(e).multiply(n),a=r.cos(i),l=r.sin(i),s=new o(i.shape);return s.data=r.stack([a,l],-1),s}_evaluate_aperture(e,t){let n=this._semiangle_cutoff/1e3,i=new o(e.shape),l=a(e,n);return i.data=r.stack([l,r.zeros(e.shape)],-1),i}build(){let[e,t]=this._get_scattering_angles(),n=this._evaluate_aberrations(e,t),i=this._evaluate_aperture(e,t),a=n.multiply(i),l=new o(a.shape);l.data=r.ifft(a.data);let s=Math.sqrt(l.abs_sqr().sum());return this._array=l.scalar_multiply(1/s,0),this}}}function g(e,t){const n=e.module();return n.variable(t()).define(["md"],r),n.variable(t()).define(["htl"],i),n.variable(t("nj")).define("nj",["require"],o),n.variable(t("ops")).define("ops",["require"],a),n.variable(t("cops")).define("cops",["require"],l),n.variable(t("atan2")).define("atan2",["nj","ops"],s),n.variable(t("lt_int_s")).define("lt_int_s",["nj","ops"],c),n.variable(t("ComplexNDArray")).define("ComplexNDArray",["nj","atan2","cops"],u),n.variable(t("fftfreq")).define("fftfreq",["nj"],_),n.variable(t("meshgrid2D")).define("meshgrid2D",["nj"],f),n.variable(t("fftshift2D")).define("fftshift2D",["nj"],p),n.variable(t("fourier_shift")).define("fourier_shift",["ComplexNDArray","nj","fftfreq","meshgrid2D"],d),n.variable(t("corner_crop")).define("corner_crop",["ComplexNDArray"],v),n.variable(t("fourier_downsample")).define("fourier_downsample",["ComplexNDArray","nj","corner_crop"],m),n.variable(t("electron_wavelength_angstroms")).define("electron_wavelength_angstroms",b),n.variable(t("electron_interaction_parameter")).define("electron_interaction_parameter",["electron_wavelength_angstroms"],h),n.variable(t("ComplexProbe")).define("ComplexProbe",["electron_wavelength_angstroms","fftfreq","meshgrid2D","nj","atan2","ComplexNDArray","lt_int_s"],w),n}function x(e){return e`# Projection Set Algorithms

Here, we will illustrate another very powerful non-convex optimization strategy used in ptychograghy, called "projection set methods".`}function j(e){return e`## Alternating Projections

Suppose we want to find the solution at the intersection of two sets:
1. a set of all points lying on the red line, and
2. a set of all point lying on the blue line.

Seems simple right? The catch is that we're only allowed to operate on one set at a time. A simple idea could be to take alternating steps where we "project" on one of the sets.

_Note:_ By "project" here we mean finding the closest point between our current location that lies on the set.

Let's try it!`}function y(e){return e.range([50,1e3],{value:250,step:50,label:"Animation speed [ms]"})}function k(e){return e.toggle({label:"Iterate!"})}function P(e,t){return e.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[e.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:9/8,y:9/16,set:1,col:"red"},{x:-.5,y:-1/16,set:2,col:"blue"},{x:9/8,y:9/64,set:2,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),e.line(t,{stroke:"orange"}),e.dot(t,{fill:"orange",fillOpacity:.5,r:10})]})}function I(e){return e.button("Reset Initial Point")}function R(e){return e`## Non-Convex Sets?

The above example was rather easy, since both our sets were convex. What do you think will happen for non-convex sets? E.g. two disconnected half-lines. Well, our naive alternating projection algorithm will get stuck!`}function z(e){return e.toggle({label:"Iterate!"})}function A(e,t){return e.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[e.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"}],{x:"x",y:"y",z:"set",stroke:"col"}),e.line(t,{stroke:"orange"}),e.dot(t,{fill:"orange",fillOpacity:.5,r:10})]})}function q(e){return e.button("Reset Initial Point")}function M(e){return e`## Generalized Projections

Turns out, we don't just have to "project" to the set exactly - we can also e.g. reflect about the set to allow for a wide search-space. More generally, we can define a "family" of generalized projection set algorithms according to the iteration:`}function D(e){return e.block`
x_{k+1} \leftarrow \left(1-a-b \right)x_k + a \Pi_1 \left[x_k\right] + b \Pi_2 \left[c \Pi[x_k]+\left(1-c\right)x_k \right]
`}function G(e,t){return t`For scalar parameters ${e`(a,b,c)`}.

Some named choices include:
- Alternating Projections (AP): ${e`(a=0,b=1,c=1)`}
- Difference Map (DM): ${e`(a=-1,b=1,c=2)`}
- Relax Reflect Reflect (RRR): ${e`(a=-\gamma,b=\gamma,c=2)`}
- Relaxed Averaged Alternating Reflections (RAAR): ${e`(a=1-2\gamma,b=\gamma,c=2)`}`}function N(e){return e.radio(["AP","DM","RRR","RAAR","Generalized"],{value:"AP",label:"Projection Name: "})}function C(e,t,n){return e.range([-1,1],{value:`${"Generalized"==t?0:n[t].a}`,step:.001,label:"Projection Parameter a"})}function $(e,t,n){return e.range([0,2],{value:`${"Generalized"==t?1:n[t].b}`,step:.001,label:"Projection Parameter b"})}function S(e,t,n){return e.range([0,2],{value:`${"Generalized"==t?1:n[t].c}`,step:.001,label:"Projection Parameter c"})}function E(e,t){return e.range([0,1],{value:""+("RRR"==t||"RAAR"==t?.875:0),step:.001,label:"Projection Parameter \u03b3"})}function T(e,t){return t`## Multiple Sets

In general, our algorithm above relies on only two generalized projections. When we have more than two sets, we need to reformulate our constraints in the form above. 

A simple way to do this is to apply our projections on a copy of the current iterate separately (${e`\Pi_1`} above), and then average our points together (${e`\Pi_2`} above).`}function V(e){return e.toggle({label:"Iterate!"})}function Z(e,t,n){let r=[...Array(e.shape[0])].map(((t,n)=>({x:e.get(n,0),y:e.get(n,1),set:5,col:"green"}))),i=t.map((e=>e.reduce(((e,t)=>[e[0]+t[0],e[1]+t[1]])).map((t=>t/e.length))));return n.plot({x:{axis:!1,domain:[-.5,9/8]},y:{axis:!1,domain:[-1/4,.5]},aspectRatio:1,style:{background:"none"},marks:[n.line([{x:-.5,y:-1/4,set:1,col:"red"},{x:1/4,y:1/8,set:1,col:"red"},{x:.5,y:1/4,set:2,col:"red"},{x:9/8,y:9/16,set:2,col:"red"},{x:-.5,y:-1/16,set:3,col:"blue"},{x:1/4,y:1/32,set:3,col:"blue"},{x:.5,y:1/16,set:4,col:"blue"},{x:9/8,y:9/64,set:4,col:"blue"},...r],{x:"x",y:"y",z:"set",stroke:"col"}),n.line(i,{stroke:"orange"}),n.dot(i,{fill:"orange",fillOpacity:.5,r:10})]})}function O(e){return e.button("Reset Initial Point")}function L(e){return e.html`<hr class="hideable-md">`}function W(e){return{AP:{a:0,b:1,c:1},DM:{a:-1,b:1,c:2},RRR:{a:-e,b:e,c:2},RAAR:{a:1-2*e,b:e,c:2}}}function B(e){let t=e.arange(0,2*Math.PI,Math.PI/512),n=[-5/4*Math.cos(Math.PI/8),-5/4*Math.sin(Math.PI/8)],r=e.sin(t.multiply(4)).divide(4).add(1),i=r.multiply(e.cos(t)).subtract(n[0]).divide(3),o=r.multiply(e.sin(t)).subtract(n[1]).divide(3);return e.stack([i,o],-1)}function F(){return function([e,t]){return[.4*(2*e+t),(2*e+t)/5]}}function H(){return function([e,t]){return[32/65*(2*e+t/4),4/65*(2*e+t/4)]}}function U(){return function([e,t]){if(8*e+4*t>=5||2*e+t<=5/8){let n=(2*e+t)/5;return[2*n,n]}if(15/16<2*e+t&&2*e+t<5/4)return[.5,1/4];if(2*e+t>5/8)return[1/4,1/8];{let n=2*t/5+4*e/5-1/8;return[2*n,n]}}}function Y(){return function([e,t]){if(8*e+t>=65/16||8*e+t<=65/32){let n=(8*e+t)/65;return[8*n,n]}if(195/64<8*e+t&&e+t<65/16)return[.5,1/16];if(8*e+t>=65/32)return[1/4,1/32];{let n=2*t/65+16*e/64-1/32;return[8*n,n]}}}function J(e,t){return function([n,r]){let i=e.add(t.pick(null,0).subtract(n).pow(2),t.pick(null,1).subtract(r).pow(2)).tolist().reduce(((e,t,n,r)=>t>r[e]?e:n),-1);return[t.get(i,0),t.get(i,1)]}}function K(){return function(e,t,[n,r,i]){let o=1-n-r,a=1-i;return function([l,s]){let[c,u]=e([l,s]),[_,f]=t([i*c+a*l,i*u+a*s]);return[o*l+n*c+r*_,o*s+n*u+r*f]}}}function X(){return function(e,t,n){return function([[r,i],[o,a],[l,s]]){return[e([r,i]),t([o,a]),n([l,s])]}}}function Q(){return function([[e,t],[n,r],[i,o]]){let a=(e+n+i)/3,l=(t+r+o)/3;return[[a,l],[a,l],[a,l]]}}function ee(e,t){return function(n,r,i,[o,a,l]){let s=1-o-a,c=1-l,u=e(n,r,i),_=t;return function([[e,t],[n,r],[i,f]]){let[[p,d],[v,m],[b,h]]=u([[e,t],[n,r],[i,f]]),[[w,g],[x,j],[y,k]]=_([[l*p+c*e,l*d+c*t],[l*v+c*n,l*m+c*r],[l*b+c*i,l*h+c*f]]);return[[s*e+o*p+a*w,s*t+o*d+a*g],[s*n+o*v+a*x,s*r+o*m+a*j],[s*i+o*b+a*y,s*f+o*h+a*k]]}}}function te(e,t,n,r,i,o){return e(t,n,[r,i,o])}function ne(e,t,n,r,i,o){return e(t,n,[r,i,o])}function re(e,t,n,r,i,o,a){return e(t,n,r,[i,o,a])}function ie(){return[[1,.3]]}function oe(){return[[1,.3]]}function ae(){return[[[1,.3],[1,.3],[1,.3]]]}function le(e,t){t.value=[[1,.3]]}function*se(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function ce(e,t){t.value=[[1,.3]]}function*ue(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function _e(e,t){t.value=[[[1,.3],[1,.3],[1,.3]]]}function*fe(e,t,n,r,i,o){let a=0;for(;e;){yield t.tick(n,++a);let e=r.length;i.value=[...r,o(r[e-1])]}}function pe(e,t){const n=e.module();n.variable(t()).define(["md"],x),n.variable(t()).define(["md"],j),n.variable(t("viewof animation_speed")).define("viewof animation_speed",["Inputs"],y),n.variable(t("animation_speed")).define("animation_speed",["Generators","viewof animation_speed"],((e,t)=>e.input(t))),n.variable(t("viewof iterate_convex")).define("viewof iterate_convex",["Inputs"],k),n.variable(t("iterate_convex")).define("iterate_convex",["Generators","viewof iterate_convex"],((e,t)=>e.input(t))),n.variable(t("two_convex_sets_plot")).define("two_convex_sets_plot",["Plot","iteration_pts_convex"],P),n.variable(t("viewof reset_convex")).define("viewof reset_convex",["Inputs"],I),n.variable(t("reset_convex")).define("reset_convex",["Generators","viewof reset_convex"],((e,t)=>e.input(t))),n.variable(t()).define(["md"],R),n.variable(t("viewof iterate_nonconvex")).define("viewof iterate_nonconvex",["Inputs"],z),n.variable(t("iterate_nonconvex")).define("iterate_nonconvex",["Generators","viewof iterate_nonconvex"],((e,t)=>e.input(t))),n.variable(t("two_nonconvex_sets_plot")).define("two_nonconvex_sets_plot",["Plot","iteration_pts_nonconvex"],A),n.variable(t("viewof reset_nonconvex")).define("viewof reset_nonconvex",["Inputs"],q),n.variable(t("reset_nonconvex")).define("reset_nonconvex",["Generators","viewof reset_nonconvex"],((e,t)=>e.input(t))),n.variable(t()).define(["md"],M),n.variable(t()).define(["tex"],D),n.variable(t()).define(["tex","md"],G),n.variable(t("viewof projection_name")).define("viewof projection_name",["Inputs"],N),n.variable(t("projection_name")).define("projection_name",["Generators","viewof projection_name"],((e,t)=>e.input(t))),n.variable(t("viewof projection_a")).define("viewof projection_a",["Inputs","projection_name","named_projection_parameters"],C),n.variable(t("projection_a")).define("projection_a",["Generators","viewof projection_a"],((e,t)=>e.input(t))),n.variable(t("viewof projection_b")).define("viewof projection_b",["Inputs","projection_name","named_projection_parameters"],$),n.variable(t("projection_b")).define("projection_b",["Generators","viewof projection_b"],((e,t)=>e.input(t))),n.variable(t("viewof projection_c")).define("viewof projection_c",["Inputs","projection_name","named_projection_parameters"],S),n.variable(t("projection_c")).define("projection_c",["Generators","viewof projection_c"],((e,t)=>e.input(t))),n.variable(t("viewof projection_gamma")).define("viewof projection_gamma",["Inputs","projection_name"],E),n.variable(t("projection_gamma")).define("projection_gamma",["Generators","viewof projection_gamma"],((e,t)=>e.input(t))),n.variable(t()).define(["tex","md"],T),n.variable(t("viewof iterate_flower")).define("viewof iterate_flower",["Inputs"],V),n.variable(t("iterate_flower")).define("iterate_flower",["Generators","viewof iterate_flower"],((e,t)=>e.input(t))),n.variable(t()).define(["flower_values","iteration_pts_flower","Plot"],Z),n.variable(t("viewof reset_flower")).define("viewof reset_flower",["Inputs"],O),n.variable(t("reset_flower")).define("reset_flower",["Generators","viewof reset_flower"],((e,t)=>e.input(t))),n.variable(t()).define(["htl"],L);const r=e.module(g);return n.import("nj",r),n.variable(t("named_projection_parameters")).define("named_projection_parameters",["projection_gamma"],W),n.variable(t("flower_values")).define("flower_values",["nj"],B),n.variable(t("region_nearest_convex_red")).define("region_nearest_convex_red",F),n.variable(t("region_nearest_convex_blue")).define("region_nearest_convex_blue",H),n.variable(t("region_nearest_nonconvex_red")).define("region_nearest_nonconvex_red",U),n.variable(t("region_nearest_nonconvex_blue")).define("region_nearest_nonconvex_blue",Y),n.variable(t("region_nearest_flower_green")).define("region_nearest_flower_green",["nj","flower_values"],J),n.variable(t("generalized_projection")).define("generalized_projection",K),n.variable(t("product_space_projection")).define("product_space_projection",X),n.variable(t("diagonal_projection")).define("diagonal_projection",Q),n.variable(t("generalized_projection_multiple")).define("generalized_projection_multiple",["product_space_projection","diagonal_projection"],ee),n.variable(t("two_convex_sets")).define("two_convex_sets",["generalized_projection","region_nearest_convex_red","region_nearest_convex_blue","projection_a","projection_b","projection_c"],te),n.variable(t("two_nonconvex_sets")).define("two_nonconvex_sets",["generalized_projection","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","projection_a","projection_b","projection_c"],ne),n.variable(t("three_nonconvex_sets")).define("three_nonconvex_sets",["generalized_projection_multiple","region_nearest_nonconvex_red","region_nearest_nonconvex_blue","region_nearest_flower_green","projection_a","projection_b","projection_c"],re),n.define("initial iteration_pts_convex",ie),n.variable(t("mutable iteration_pts_convex")).define("mutable iteration_pts_convex",["Mutable","initial iteration_pts_convex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_convex")).define("iteration_pts_convex",["mutable iteration_pts_convex"],(e=>e.generator)),n.define("initial iteration_pts_nonconvex",oe),n.variable(t("mutable iteration_pts_nonconvex")).define("mutable iteration_pts_nonconvex",["Mutable","initial iteration_pts_nonconvex"],((e,t)=>new e(t))),n.variable(t("iteration_pts_nonconvex")).define("iteration_pts_nonconvex",["mutable iteration_pts_nonconvex"],(e=>e.generator)),n.define("initial iteration_pts_flower",ae),n.variable(t("mutable iteration_pts_flower")).define("mutable iteration_pts_flower",["Mutable","initial iteration_pts_flower"],((e,t)=>new e(t))),n.variable(t("iteration_pts_flower")).define("iteration_pts_flower",["mutable iteration_pts_flower"],(e=>e.generator)),n.variable(t("two_convex_sets_reset")).define("two_convex_sets_reset",["reset_convex","mutable iteration_pts_convex"],le),n.variable(t("two_convex_sets_generator")).define("two_convex_sets_generator",["iterate_convex","Promises","animation_speed","iteration_pts_convex","mutable iteration_pts_convex","two_convex_sets"],se),n.variable(t("two_nonconvex_sets_reset")).define("two_nonconvex_sets_reset",["reset_nonconvex","mutable iteration_pts_nonconvex"],ce),n.variable(t("two_nonconvex_sets_generator")).define("two_nonconvex_sets_generator",["iterate_nonconvex","Promises","animation_speed","iteration_pts_nonconvex","mutable iteration_pts_nonconvex","two_nonconvex_sets"],ue),n.variable(t()).define(["reset_flower","mutable iteration_pts_flower"],_e),n.variable(t()).define(["iterate_flower","Promises","animation_speed","iteration_pts_flower","mutable iteration_pts_flower","three_nonconvex_sets"],fe),n}function de(e){return e}function ve(e){return e}function me(e){return e}function be(e){return e}function he(e){return e}function we(e){return e}function ge(e){return e}function xe(e){return e}function je(e){return e}function ye(e){return e.html`<hr class="hideable-md">`}function ke(e){return e}function Pe(e){return e}function Ie(e,t){const n=e.module();n.variable(t()).define(["viewof animation_speed"],de),n.variable(t()).define(["viewof iterate_nonconvex"],ve),n.variable(t()).define(["two_nonconvex_sets_plot"],me),n.variable(t()).define(["viewof reset_nonconvex"],be),n.variable(t()).define(["viewof projection_name"],he),n.variable(t()).define(["viewof projection_a"],we),n.variable(t()).define(["viewof projection_b"],ge),n.variable(t()).define(["viewof projection_c"],xe),n.variable(t()).define(["viewof projection_gamma"],je),n.variable(t()).define(["htl"],ye);const r=e.module(pe);return n.import("viewof animation_speed",r),n.import("animation_speed",r),n.import("viewof iterate_nonconvex",r),n.import("iterate_nonconvex",r),n.import("viewof reset_nonconvex",r),n.import("reset_nonconvex",r),n.import("two_nonconvex_sets_plot",r),n.import("two_nonconvex_sets_generator",r),n.import("two_nonconvex_sets_reset",r),n.import("viewof projection_name",r),n.import("projection_name",r),n.import("viewof projection_a",r),n.import("projection_a",r),n.import("viewof projection_b",r),n.import("projection_b",r),n.import("viewof projection_c",r),n.import("projection_c",r),n.import("viewof projection_gamma",r),n.import("projection_gamma",r),n.variable(t()).define(["two_nonconvex_sets_generator"],ke),n.variable(t()).define(["two_nonconvex_sets_reset"],Pe),n}n.d(t,{Z:()=>Ie})}}]);